MoreInterfaces 是一个为Minecraft提供第三方网络接口的Mod，为了方便理解，可以将其视作超级简易的一款RPC插件。
## 简介
MoreInterfaces 的服务对象为包括普通玩家在内的第三方开发者
并将会尽可能的为第三方软件的控制提供几乎Minecraft全部版本（`1.14以上`）的网络api接口
通过内置的多种api，您可以在外部实现动态的服务更新！
目前只支持：Fabric、Forge、NeoForge
后续预计支持：Bukkit、Quilt

## 注意
我们不建议任何第三方开发者开发MoreInterfaces的附属mod，因为当MoreInterfaces进行更新时，会同步更新全部受支持版本的MoreInterfaces
您的附属mod在此过程中很可能会因为MoreInterfaces的内部api变动产生不可预料的情况，`如果有附属需求请直接合并代码请求`

## 使用
客户端可选/服务端可选
根据MoreInterfaces的打包类型，直接放入`mod/plugin`文件夹即可

## 配置
MoreInterfaces在游戏/服务器启动时会在`config`文件夹下生成一个名为`moreinterfaces.json`的配置文件
- `enable`：是否启用MoreInterfaces的api服务（您即使没有开启api服务，仍然可以通过指令的方式使用内部的部分功能）
- `port`：MoreInterfaces的api服务端口
- `tokens`：这是一个列表，每一个`token`对象都有两个属性，一个是可以随意定制的`token`本身，另一个则是`token`对应的权限组
- `powers`：这也是一个列表，每一个`power`都表示一个权限组，权限组有一个唯一的纯数字的`id`以及一个权限列表（此列表对`0`级这种拥有全部api访问权限的用户没意义）。
- `aesKey`：请不要随意修改此选项，此条目用于与远程数据包进行加密数据传输

注意：权限列表会保证至少有一个`0`级别（全部权限）的权限组，即使手动移除也会自动生成

## 客户端访问MoreInterfaces API

### 数据包结构
网络数据包由以下部分组成：

1. **模块标识（MODS）**：用于标识发送消息的模块`moreinterfaces`，长度为14字节
2. **版本号（VERSION）**：用于标识消息的版本，长度为5字节
3. **换行符（\n）**：用于分隔模块标识和版本号，长度为2字节
4. **序列化类型（type）**：用于标识消息的序列化类型，长度为1字节
5. **保留字节（0xff）**：用于保留，长度为1字节
6. **消息类型（type）**：用于标识消息的类型，长度为4字节
7. **消息长度（length）**：用于标识消息内容的长度，长度为4字节
8. **消息内容（content）**：消息的实际内容

```
+----------------+----------------+----------------+----------------+----------------+----------------+----------------+
|    MODS        |    VERSION     |    \n          |    type        |    0xff        |    type        |    length      |
+----------------+----------------+----------------+----------------+----------------+----------------+----------------+
|    content     |                |                |                |                |                |                |
+----------------+----------------+----------------+----------------+----------------+----------------+----------------+
```

### 序列化类型用于标识消息的序列化方式，目前支持以下几种：

- JSON（byte:1）：使用JSON格式进行序列化，这将会是明文
- AES_JSON（byte:2）: 使用JSON格式进行序列化的同时采用更安全的网络加密。

### 消息类型

消息类型用于标识消息的具体类型，可以通过`MessageFactory.valueOf`方法获取对应的`Message`类。

### 异常处理

在解码过程中，如果出现异常，会调用`exceptionCaught`方法进行处理。如果异常是`JsonSyntaxException`，则会发送一个`NotSessionErrorMessage`消息，并打印异常堆栈信息。

### 特别事项

关于服务端和客户端采用的序列化方式是动态的，如果某一刻客户端返回了一个`AES_JSON`类型的数据包，那么服务端后续发送的相应包全部都会为`AES_JSON`。
